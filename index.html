<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Game Changer 3D workshops</title>
    <style>
        body {
            background-color: black;
            margin: 0;
        }
        canvas {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
      }
    </script>
    <script type="module">
        import * as THREE from 'three';

        const clock = new THREE.Clock();

        const walls = []
        let camera, scene, renderer, delta
        let playerMesh, playerBox

        let playerTargetY = -10

        function lerp (start, end, val){
            return (1-val)*start+val*end
        }

        function initScene() {
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );

            camera.position.z = 2;
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer( { antialias: true } );

            renderer.setSize( window.innerWidth, window.innerHeight );

            renderer.setAnimationLoop( animation );
            document.body.appendChild( renderer.domElement );
        }

        function animation( time ) {
            const delta = clock.getDelta();

            movePlayer(delta, time)
            moveWalls(delta)
            handleCollisions()

            renderer.render(scene, camera);
        }

        const createGeometryWithBoundingBox = ({
            size,
        }) => {
            const { x, y, z } = size

            const geometry = new THREE.BoxGeometry(x, y, z);
            const material = new THREE.MeshNormalMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            const box = new THREE.Box3();

            mesh.geometry.computeBoundingBox();

            // box.copy( mesh.geometry.boundingBox ).applyMatrix4( mesh.matrixWorld );

            return {
                mesh,
                box
            }
        }

        const handleCollisions = () => {
            walls.forEach(({
               upperWallMesh,
               bottomWallMesh,
               upperWallBox,
               bottomWallBox
            }) => {
               upperWallBox.copy(upperWallMesh.geometry.boundingBox).applyMatrix4(upperWallMesh.matrixWorld);
               bottomWallBox.copy(bottomWallMesh.geometry.boundingBox).applyMatrix4(bottomWallMesh.matrixWorld);
               playerBox.copy(playerMesh.geometry.boundingBox).applyMatrix4(playerMesh.matrixWorld);

               console.log(playerBox.intersectsBox(upperWallBox), playerBox.intersectsBox(bottomWallBox))
            })
        }

        const movePlayer = (delta, time) => {
            if(playerMesh){
                playerMesh.rotation.x = time / 2000;
                playerMesh.rotation.y = time / 1000;

                playerMesh.position.y = lerp(playerMesh.position.y, playerTargetY, .1 * delta)
            }

            playerTargetY = lerp(playerTargetY, -10, .9 * delta)
        }

        const moveWalls = (delta) => {
            walls.forEach(({
                wallParent,
                upperWallBox,
                bottomWallBox
            }) => {
                wallParent.position.x = wallParent.position.x - (.7 * delta)
            })
        }

        function addPlayer() {
            const { mesh, box } = createGeometryWithBoundingBox({
                size: {
                    x: .2,
                    y: .2,
                    z: .2
                }
            })

            mesh.position.x = -1
            scene.add( mesh );

            playerMesh = mesh
            playerBox = box
        }

        function addWall() {
            const wallParent = new THREE.Object3D();

            const { mesh: upperWallMesh, box: upperWallBox } = createGeometryWithBoundingBox({
                size: {
                    x: .2,
                    y: 2,
                    z: .2
                }
            })

            upperWallMesh.position.x = 3
            upperWallMesh.position.y = -1.5
            wallParent.add(upperWallMesh)

            const { mesh: bottomWallMesh, box: bottomWallBox } = createGeometryWithBoundingBox({
                size: {
                    x: .2,
                    y: 2,
                    z: .2
                }
            })

            bottomWallMesh.position.x = 3
            bottomWallMesh.position.y = 1.5
            wallParent.add(bottomWallMesh)

            wallParent.position.y = getRandomInt(-9,9)/10

            walls.push({
                wallParent,
                upperWallMesh,
                bottomWallMesh,
                upperWallBox,
                bottomWallBox
            })

            scene.add(wallParent);

            setTimeout(addWall, 2000)
        }

        initScene()
        addPlayer()
        addResizeListener()

        addWall()

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min) + min); // The maximum is exclusive and the minimum is inclusive
        }

        // util

        window.test = () => {
            walls.forEach(object => {
                const y = getRandomInt(-9,9)/10
                console.log(y)
                object.position.y = y
            })
        }

        window.jump = () => {
            playerTargetY = playerMesh.position.y + 10
        }

        function addResizeListener() {
            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize(){
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
    </script>
</head>
<body>
<canvas id="canvas"></canvas>
</body>
</html>
